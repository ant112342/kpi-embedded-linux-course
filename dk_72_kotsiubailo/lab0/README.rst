=================================================
**Лабораторна робота №0 Робота з потоками**
=================================================


**Завдання:**
~~~~~~~~~~~~~
Написати код в якому:

* Створити глобальну змінну та ініціалізувати її нулем;
* Створити функцію потоку,яка N разів додає до цієї змінної К - (в моєму випадку це 1);
* Запустити два потоки з цією функцією;
* Дочекатись завершення потоків використовуючи ``pthread_join()`` ;
* Вивести в ``stdout`` очікуване та фактичне значення глобальної змінної;

**Хід роботи:**
---------------
Для полегшення написання та відладки коду спочатку було вирішено створити MakeFile з рецептами для компіляції проекту та чистки артефактів

Особливістю написаного MakeFile є:

* змінна OPTFLAG (флаг оптимізації) - її ми можемо змінювати при запуску MakeFile. Це дозволить нам протестувати програму при різниї оптимізаціях;
* рецепт ``asm`` що дозволяє отримати асемблерний лістинг нашого коду;

Написаний код знаходиться в директорії ``src`` під назвою ``threads.c``.


* ``<pthread.h>`` - бібліотека , яка дозволяє працювати з потоками.
*   ``volatile``  -  модифікатор,який буде казати компілятору про те, що значення змінної може змінюватися ззовні і що компілятор не буде оптимізувати цю змінну. Це робиться для того, щоб далі перевірити коректність результату при різних оптимізаціях.
* ``struct val``  - структура в якій дві змінні ( num - що прибавляти, count - скільки разів прибавляти
Змінні будуть мати тип long  тому що при перевірці флага оптимізації різниця буде видна тільки при великих значеннях

.. code-block:: C

typedef unsigned long type_cnt;

volatile type_cnt gl_var = 0;

struct var {
  type_cnt num;
  type_cnt count;
};

Загальний вигляд функції ``func``:
.. code-block:: C

  void *func(void *the_val) {

  type_cnt val_n = ((struct var *)the_val)->num;
  type_cnt val_cnt = ((struct var *)the_val)->count;

  for (type_cnt i = 0; i < val_cnt; i++) {
    gl_var += val_n;
  }
  pthread_exit(0);
}
Функція ``check``:

* ``sscanf`` - Функція sscanf () ідентична функції scanf () у всьому, крім того, що дані зчитуються з масиву, вказаного аргументом buf, а не з файлу stdin.
Повертає нуль якщо нічого не було введено.
  
.. code-block:: C
bool is_valfit(char *arg, type_cnt *res) {
  int result;
  char unused;
  if (1 != sscanf(arg, "%d\"%c\"", &result, &unused))
    return 1;
  else
    *res = result;
  return 0;
}


 Функція ``main``:

За допомогою функції ``pthread_create`` створються потоки
А функція ``pthread_join`` очікує їх завершення. Лістинг функції:

.. code-block:: C

int main(int argc, char *argv[]) {

  struct var used_var;

  if (argc != 3) {
    fprintf(stderr, "%s : wrrong amount of arguments : %d ; should be 2 \n",
            argv[0], argc - 1);
    exit(1);
  }

  if (check_in(argv[1], &used_var.num) || check_in(argv[2], &used_var.count)) {

    fprintf(stderr, "\nWrong input types\n");
    exit(1);
  }

  pthread_t *threads = (pthread_t *)malloc(2 * sizeof(pthread_t));

  for (int i = 0; i < 2; i++) {

    pthread_create(&(threads[i]), NULL, &func, &used_var);
  }

  for (int i = 0; i < 2; i++)
    pthread_join(threads[i], NULL);

  free(threads);

  printf("Expected value: %lu \n", 2 * used_var.num * used_var.count);
  printf("Real value: %lu \n", gl_var);

  return 0;
}
Приклад виконання програми:

.. code-block:: C
[thd@tm build]$ ./threads 5000004503040 545495939430493
Expected value: 971461026877824000 
Real value: 541380359331463680 


Висновки
--------
в результаті роботи програми з різними прапорцями оптимізації ,а саме, ``O0`` та ``O2``виникають різні результати роботи. При оплимізації ``O0`` результат не вірний по причині не атомарності виконуваних інструкцій, а саме, порушення послідовності
зчитування модифікування запису одного потоку іншим.Як результат у виподку такої послідовності виконання інструкцій після виконання суми обома потоками маємо збільшення змінної на k,
 а не на 2k (як повинно бути).
При оптимізації ``O2`` компілятор приймає до уваги що змінна ``count`` ніде не використовується 
під час суми, вона використовується лише в кінці під час виведення результату, і одказу записує до змінної результат інкрементації.
При використанні модифікатору ``volatile`` підчас ініціалізації змінної, компілятор не оптимізує змінну, тому і результат роботи програми такий самий
як і при оптимізації ``O0``.

